## Directory Structure Overview
```
├── AclNNInvocation             // Invocation of LpNormV2Custom operator via aclnn
│   ├── inc                     // Header files directory
│   │   ├── common.h            // Declaration of common methods class for reading binary files
│   │   ├── op_runner.h         // Operator description declaration file, includes operator input/output, operator type, and input/output descriptions
│   │   └── operator_desc.h     // Declaration file for operator runtime-related information, including input/output counts, input/output sizes, etc.
│   ├── input                   // Directory for input data generated by scripts
│   ├── output                  // Directory for storing operator runtime output data and ground truth data
│   ├── scripts
│   │   ├── acl.json            // acl configuration file
│   │   ├── gen_data.py         // Script for generating input and ground truth data
│   │   └── verify_result.py    // Ground truth comparison file
│   ├── src
│   │   ├── CMakeLists.txt      // Compilation rules file
│   │   ├── common.cpp          // Implementation file for common functions, including reading binary files
│   │   ├── main.cpp            // Entry point for single operator invocation application
│   │   ├── op_runner.cpp       // Implementation file for the main process of single operator invocation
│   │   └── operator_desc.cpp   // Constructs the input and output descriptions for the operator
│   └── run.sh                  // Script for execution commands
```

## Code Implementation Overview
After completing the development and deployment of the custom operator, you can verify the functionality of the single operator via single operator invocation. The `src/main.cpp` code is for executing the single operator API. The single operator API execution is based on C language APIs, eliminating the need for providing an offline model conversion description file; it directly calls the single operator API interface.

Once the custom operator is compiled and deployed, a single operator API is automatically generated and can be directly invoked in the application. The operator API is generally defined as a "two-part interface," as follows:
```cpp
aclnnStatus aclnnLpNormV2CustomGetWorkspaceSize(const aclTensor *x, float pOptional, const aclIntArray * axes, bool keepdimOptional, float epsilonOptional, const aclTensor *y, uint64_t workspaceSize, aclOpExecutor **executor);
aclnnStatus aclnnLpNormV2Custom(void *workspace, int64_t workspaceSize, aclOpExecutor **executor, aclrtStream stream);
```

Where aclnnLpNormV2CustomGetWorkspaceSize is the first stage interface, mainly used to calculate how much workspace memory is needed during this API call. After obtaining the required workspace size for this API calculation, allocate Device-side memory according to the workspaceSize, and then call the second stage interface aclnnCrossValue to perform the calculation. For specific reference, see the [AscendCL Single Operator Invocation](https://hiascend.com/document/redirect/CannCommunityAscendCInVorkSingleOp) > Single Operator API Execution section.

## Running Sample Operator
### 1. Compile the Operator Project
Before running this sample, please refer to [Compile the Operator Project](../README.md#operatorcompile) for preliminary preparations.

### 2. Run the Aclnn Invocation Sample

- Enter the example directory

  ```bash
  cd ${git_clone_path}/samples/operator_contrib/LpNormV2CustomSample/FrameworkLaunch/AclNNInvocation
  ```

- Execute the sample:
  
  During execution, the sample will automatically generate test data, then compile and run the aclnn sample, and finally verify the execution results. For detailed steps, please refer to the `run.sh` script.
  
  ```bash
  bash run.sh
  ```