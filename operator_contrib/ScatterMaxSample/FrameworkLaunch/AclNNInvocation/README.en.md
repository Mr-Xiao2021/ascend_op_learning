## Directory Structure
``` 
├── AclNNInvocation             // Invokes the ScatterMax operator via the aclnn method
│   ├── inc                     // Header files directory
│   │   ├── common.h            // Declares the common methods class for reading binary files
│   │   ├── op_runner.h         // Operator description header file, includes operator input/output, operator type, input and output descriptions
│   │   └── operator_desc.h     // Declares operator runtime-related information, such as the number and size of inputs/outputs
│   ├── input                   // Directory for storing input data generated by the script
│   ├── output                  // Directory for storing the operator’s output data and the ground truth data
│   ├── scripts
│   │   ├── acl.json            // acl configuration file
│   │   ├── gen_data.py         // Script for generating input data and ground truth data
│   │   └── verify_result.py    // Script for comparing results with the ground truth
│   ├── src
│   │   ├── CMakeLists.txt      // Compilation rules file
│   │   ├── common.cpp          // Implementation file for the common functions, such as reading binary files
│   │   ├── main.cpp            // Entry point for the single operator invocation application
│   │   ├── op_runner.cpp       // Main implementation file for the single operator invocation process
│   │   └── operator_desc.cpp   // Constructs the operator’s input and output descriptions
│   └── run.sh                  // Execution command script
``` 

## Code Implementation
After completing the development and deployment of the custom operator, you can verify the functionality of the single operator by invoking it. The code in src/main.cpp is the execution method for the single operator API. Single operator API execution is based on the C language API to execute the operator, without the need for a single operator description file for offline model conversion, directly calling the single operator API interface.

After the custom operator is compiled and deployed, the single operator API is automatically generated and can be directly called in the application. The operator API is generally defined in the form of a "two-stage interface", such as:
   ```cpp    
   aclnnStatus aclnnScatterMaxGetWorkspaceSize(const aclTensor *x, const aclTensor *y, const alcTensor *out, uint64_t workspaceSize, aclOpExecutor **executor);
   aclnnStatus aclnnScatterMax(void *workspace, int64_t workspaceSize, aclOpExecutor **executor, aclrtStream stream);
   ```
The aclnnScatterMaxGetWorkspaceSize is the first stage interface, mainly used to calculate how much workspace memory is needed for this API call. After obtaining the workspace size required for this API calculation, allocate Device-side memory according to the workspaceSize, and then call the second stage interface aclnnScatterMax to perform the calculation. For specific reference, see the [AscendCL Single Operator Invocation](https://hiascend.com/document/redirect/CannCommunityAscendCInVorkSingleOp) > Single Operator API Execution section.

## Running the Example Operator
### 1. Compile the Operator Project
Before running this example, refer to [Compile the Operator Project](../README.en.md#operatorcompile) to complete the preparation steps.

### 2. Running the Aclnn Example
- Enter the example directory

    ```bash
    cd ${git_clone_path}/samples/operator_contrib/ScatterMaxSample/FrameworkLaunch/AclNNInvocation
    ```

- Example execution

    During the example execution, test data will be automatically generated, then the aclnn example will be compiled and run, and finally, the running results will be verified. The specific process can be seen in the run.sh script.

    ```bash
    bash run.sh
    ```

## Update Log
| Date       | Updates                     |
|------------|------------------------------|
| 2024/05/28 | Added this README            |
| 2024/07/24 | Modified the README format    |